import pathlib
import sys
import json
import signal

# import fakefaas as ff
import libff as ff

modulePath = pathlib.Path(__file__).parent.resolve()
ferModelPath = modulePath / 'emotion_ferplus' / "model.onnx"

def emotion_map(classes, N=1):
    """Take the most probable labels (output of postprocess) and returns the 
    top N emotional labels that fit the picture."""

    emotion_table = {'neutral':0, 'happiness':1, 'surprise':2, 'sadness':3, 
                     'anger':4, 'disgust':5, 'fear':6, 'contempt':7}

    emotion_keys = list(emotion_table.keys())
    emotions = []
    for i in range(N):
        emotions.append(emotion_keys[classes[i]])
    return emotions


def softmax(x):
    """Compute softmax values (probabilities from 0 to 1) for each possible label."""
    x = x.reshape(-1)
    e_x = np.exp(x - np.max(x))
    return e_x / e_x.sum(axis=0)


def toClassIds(scores):
    """This function takes the scores generated by the network and 
    returns the class IDs in decreasing order of probability."""
    prob = softmax(scores)
    prob = np.squeeze(prob)
    classes = np.argsort(prob)[::-1]
    return classes


class GlobalImport:
    """Allows you to import modules in a function and have them put in the global context. Good for conditional imports. We use it to abstract imports into their own function for profiling purposes.
    Taken from: Rafal Grabie https://stackoverflow.com/questions/11990556/how-to-make-global-imports-from-a-function"""

    def __enter__(self):
        return self

    def __call__(self):
        import inspect
        self.collector = inspect.getargvalues(inspect.getouterframes(inspect.currentframe())[1].frame).locals

    def __exit__(self, *args):
        globals().update(self.collector)

class Model:
    """This is a generic interface to a model, it should be wrapped in a
    ModelWorker.remoteModel in order to interact with libff"""

    @staticmethod
    def imports():
        with GlobalImport() as gi:
            import onnxruntime, onnx
            import onnx.numpy_helper
            import numpy as np
            gi()
        

    def __init__(self, provider="CUDAExecutionProvider", profTimes=None):
        with ff.timer("imports", profTimes):
            Model.imports()

        opts = onnxruntime.SessionOptions()
        opts.optimized_model_filepath = "optModel.onnx"
        # opts.enable_profiling = True 

        with ff.timer("onnxruntime_session_init", profTimes):
            ferSession = onnxruntime.InferenceSession(
                    str(ferModelPath),
                    sess_options=opts,
                    providers=[provider])

        self.session = ferSession
        self.inputName = ferSession.get_inputs()[0].name
        self.outputName = ferSession.get_outputs()[0].name
        self.provider = provider


    def pre(self, datString):
        tensor = onnx.TensorProto()
        tensor.ParseFromString(datString)

        npDat = onnx.numpy_helper.to_array(tensor)
        return npDat 


    def post(self, onnxRes):
        return emotion_map(toClassIds(onnxRes[0]))


    def run(self, data):
        return self.session.run([self.outputName], {self.inputName : data})


    def inputs(self):
        # Load a test image (we'll just use the same image over and over for simplicity)
        with open(modulePath / 'emotion_ferplus' / 'test_data_set_0' / 'input_0.pb', 'rb') as f:
            inStr = f.read()

        return inStr


def LibffInvokeRegister():
    """Callback required by libff.invoke in DirectRemoteFunc mode"""

    # Need to be able to import from the serve directory (where ModelWorker is defined)
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent.parent))
    import ModelWorker

    modelHandler = ModelWorker.modelServer(Model)
    return ModelWorker.getFuncMap(modelHandler)


if __name__ == "__main__":
    """Used when invoked as a libff.invoke.ProcessRemoteFunc"""
    import libff.invoke

    # Need to be able to import from the serve directory (where ModelWorker is defined)
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent.parent))
    import ModelWorker

    modelHandler = ModelWorker.modelServer(Model)
    libff.invoke.RemoteProcessServer(ModelWorker.getFuncMap(modelHandler), sys.argv[1:])
